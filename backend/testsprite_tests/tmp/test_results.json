[
  {
    "projectId": "e033221d-4754-43c9-9221-ccf7efb399bf",
    "testId": "90f5c340-8aea-410e-812e-673fc38e8693",
    "userId": "84b82428-8041-70a5-857a-0c34799496ce",
    "title": "TC001-user registration with email validation and jwt token return",
    "description": "Test the /register endpoint to ensure new users can register with valid username, email, and password. Verify that duplicate usernames are rejected, email format is validated, and a JWT access token is returned upon successful registration.",
    "code": "import requests\nfrom requests.exceptions import RequestException\nimport re\n\nBASE_URL = \"http://localhost:8000\"\nREGISTER_URL = f\"{BASE_URL}/register\"\nTIMEOUT = 30\n\ndef test_user_registration_email_validation_jwt_token_return():\n    # Helper function to register a user\n    def register_user(username, email, password):\n        payload = {\n            \"username\": username,\n            \"email\": email,\n            \"password\": password\n        }\n        try:\n            response = requests.post(REGISTER_URL, json=payload, timeout=TIMEOUT)\n            return response\n        except RequestException as e:\n            raise AssertionError(f\"Request to /register failed: {e}\")\n\n    # Unique username and email base for this test run\n    import uuid\n    unique_id = uuid.uuid4().hex[:8]\n\n    valid_username = f\"user_{unique_id}\"\n    valid_email = f\"{unique_id}@example.com\"\n    valid_password = \"StrongPass123!\"\n\n    # 1. Successful registration with valid username, email, password\n    resp = register_user(valid_username, valid_email, valid_password)\n    assert resp.status_code == 200, f\"Expected 200 OK but got {resp.status_code} with body {resp.text}\"\n    json_response = resp.json()\n    assert \"access_token\" in json_response, \"Response JSON missing 'access_token'\"\n    assert json_response.get(\"token_type\") == \"bearer\", \"token_type should be 'bearer'\"\n\n    # The access_token should be a non-empty string\n    access_token = json_response[\"access_token\"]\n    assert isinstance(access_token, str) and len(access_token) > 0, \"Invalid access_token returned\"\n\n    # Simple email format validation for the registration email\n    email_regex = r\"^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$\"\n    assert re.match(email_regex, valid_email), \"Provided email does not match email format\"\n\n    # 2. Duplicate username registration should be rejected (400)\n    resp_dup_username = register_user(valid_username, f\"diff_{valid_email}\", valid_password)\n    assert resp_dup_username.status_code == 400, f\"Duplicate username should return 400 but got {resp_dup_username.status_code}\"\n    assert \"Usuario ya existe\" in resp_dup_username.text, \"Expected error message for duplicate username\"\n\n    # 3. Invalid email format should be rejected (likely 422 Unprocessable Entity or 400)\n    invalid_emails = [\"plainaddress\", \"missing_at_sign.com\", \"missingdomain@.com\", \"missingdot@domaincom\", \"@missingusername.com\"]\n    for bad_email in invalid_emails:\n        resp_bad_email = register_user(f\"user_{uuid.uuid4().hex[:6]}\", bad_email, valid_password)\n        # Accepting 400 or 422 for validation errors depending on FastAPI response\n        assert resp_bad_email.status_code in (400, 422), f\"Invalid email '{bad_email}' should be rejected with 400/422 but got {resp_bad_email.status_code}\"\n\ntest_user_registration_email_validation_jwt_token_return()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-13T20:24:25.165Z",
    "modified": "2026-02-13T20:24:59.733Z"
  },
  {
    "projectId": "e033221d-4754-43c9-9221-ccf7efb399bf",
    "testId": "595ab6f0-81e7-4a4c-940f-69cc5c561ab6",
    "userId": "84b82428-8041-70a5-857a-0c34799496ce",
    "title": "TC002-user login with remember me feature and jwt token in cookie",
    "description": "Test the /login endpoint to verify users can login with correct credentials. Check that the remember_me flag extends session duration, JWT token is returned in response, and httponly cookie is set. Invalid credentials should return 401 Unauthorized.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n\ndef test_user_login_with_remember_me_and_jwt_cookie():\n    # Generate unique user info for registration\n    unique_suffix = str(uuid.uuid4()).replace(\"-\", \"\")\n    username = f\"user_{unique_suffix}\"\n    password = \"TestPass123!\"\n    email = f\"{unique_suffix}@example.com\"\n\n    register_url = f\"{BASE_URL}/register\"\n    login_url = f\"{BASE_URL}/login\"\n\n    user_data = {\n        \"username\": username,\n        \"password\": password,\n        \"email\": email\n    }\n\n    login_data = {\n        \"username\": username,\n        \"password\": password,\n        \"remember_me\": True\n    }\n\n    # Register user\n    register_resp = requests.post(register_url, json=user_data, timeout=TIMEOUT)\n    assert register_resp.status_code == 200, f\"Registration failed: {register_resp.text}\"\n    register_json = register_resp.json()\n    assert \"access_token\" in register_json\n    assert register_json.get(\"token_type\") == \"bearer\"\n\n    # Login with correct credentials and remember_me=True\n    login_resp = requests.post(login_url, json=login_data, timeout=TIMEOUT)\n    assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n\n    login_json = login_resp.json()\n    assert \"access_token\" in login_json, \"JWT token missing in login response\"\n    assert login_json.get(\"token_type\") == \"bearer\"\n\n    # Check that httponly cookie is set with the token\n    cookies = login_resp.cookies\n    access_token_cookie = cookies.get(\"access_token\")\n    assert access_token_cookie is not None, \"access_token cookie not set on login\"\n    # httponly cookie attribute cannot be checked directly via requests cookies,\n    # but absence of the cookie would be a failure.\n\n    # Try login with invalid credentials\n    invalid_login_data = {\n        \"username\": username,\n        \"password\": \"WrongPassword!\",\n        \"remember_me\": False\n    }\n    invalid_login_resp = requests.post(login_url, json=invalid_login_data, timeout=TIMEOUT)\n    assert invalid_login_resp.status_code == 401, f\"Invalid login did not return 401 but {invalid_login_resp.status_code}\"\n\n# Execute the test function\ntest_user_login_with_remember_me_and_jwt_cookie()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-13T20:24:25.171Z",
    "modified": "2026-02-13T20:25:03.604Z"
  },
  {
    "projectId": "e033221d-4754-43c9-9221-ccf7efb399bf",
    "testId": "ab05133a-44df-4d2f-9fd1-33a2777ba4b0",
    "userId": "84b82428-8041-70a5-857a-0c34799496ce",
    "title": "TC003-user logout clears authentication cookie",
    "description": "Test the /logout endpoint to ensure it clears the access_token cookie and returns a successful logout message.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_user_logout_clears_auth_cookie():\n    # Prepare unique user data for registration\n    unique_suffix = uuid.uuid4().hex[:8]\n    username = f\"testuser_{unique_suffix}\"\n    password = \"TestPassword123!\"\n    email = f\"{unique_suffix}@example.com\"\n\n    session = requests.Session()\n\n    try:\n        # Register user\n        register_payload = {\n            \"username\": username,\n            \"password\": password,\n            \"email\": email\n        }\n        reg_resp = session.post(\n            f\"{BASE_URL}/register\",\n            json=register_payload,\n            timeout=TIMEOUT\n        )\n        assert reg_resp.status_code == 200, f\"Register failed: {reg_resp.text}\"\n        assert \"access_token\" in reg_resp.json()\n\n        # Login user\n        login_payload = {\n            \"username\": username,\n            \"password\": password,\n            \"remember_me\": False\n        }\n        login_resp = session.post(\n            f\"{BASE_URL}/login\",\n            json=login_payload,\n            timeout=TIMEOUT\n        )\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        login_json = login_resp.json()\n        assert \"access_token\" in login_json\n        # Check that access_token cookie is set (httponly)\n        cookies = login_resp.cookies\n        assert \"access_token\" in cookies, \"access_token cookie missing after login\"\n\n        # Before logout, confirm access_token cookie present in session.cookies\n        assert \"access_token\" in session.cookies, \"access_token cookie missing in session before logout\"\n\n        # Logout user - this should clear the access_token cookie\n        logout_resp = session.post(\n            f\"{BASE_URL}/logout\",\n            timeout=TIMEOUT\n        )\n        assert logout_resp.status_code == 200, f\"Logout failed: {logout_resp.text}\"\n        logout_json = logout_resp.json()\n        assert logout_json.get(\"message\") == \"logged out\"\n\n        # After logout, the access_token cookie should be cleared/expired\n        # We verify by checking if session cookies no longer contain 'access_token' or that its value is empty\n        # Manually update session cookies with response cookies from logout (which clears the cookie)\n        session.cookies.update(logout_resp.cookies)\n        cookie_value = session.cookies.get(\"access_token\")\n        # It can be None or an empty string or expired (depends on implementation),\n        # assert that cookie is either missing or empty string\n        assert not cookie_value, \"access_token cookie was not cleared after logout\"\n\n    finally:\n        # Cleanup: no persistent user deletion endpoint described, so no explicit cleanup feasible\n        # This test leaves a user registered; in real env a cleanup step might be needed.\n        pass\n\ntest_user_logout_clears_auth_cookie()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-13T20:24:25.176Z",
    "modified": "2026-02-13T20:25:13.675Z"
  },
  {
    "projectId": "e033221d-4754-43c9-9221-ccf7efb399bf",
    "testId": "ef091237-f1d1-44a7-bb4b-3b9ad7745a46",
    "userId": "84b82428-8041-70a5-857a-0c34799496ce",
    "title": "TC004-authenticated user profile retrieval",
    "description": "Test the /me endpoint to verify that only authenticated users can retrieve their profile information including id, username, email, created_at, and last_login. Invalid or missing tokens should return 401 Unauthorized.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n\ndef test_authenticated_user_profile_retrieval():\n    # Generate random user data for registration\n    random_suffix = uuid.uuid4().hex[:8]\n    username = f\"testuser_{random_suffix}\"\n    password = \"TestPassword123!\"\n    email = f\"{random_suffix}@example.com\"\n\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Register a new user to get token\n    register_payload = {\n        \"username\": username,\n        \"password\": password,\n        \"email\": email\n    }\n    register_resp = requests.post(f\"{BASE_URL}/register\", json=register_payload, headers=headers, timeout=TIMEOUT)\n    assert register_resp.status_code == 200, f\"Registration failed: {register_resp.text}\"\n    register_json = register_resp.json()\n    assert \"access_token\" in register_json and register_json.get(\"token_type\") == \"bearer\"\n    token = register_json[\"access_token\"]\n    auth_header = {\"Authorization\": f\"Bearer {token}\"}\n\n    try:\n        # Successful profile retrieval with valid token\n        me_resp = requests.get(f\"{BASE_URL}/me\", headers=auth_header, timeout=TIMEOUT)\n        assert me_resp.status_code == 200, f\"/me with valid token failed: {me_resp.text}\"\n        profile = me_resp.json()\n        # Validate presence and types of expected fields\n        assert isinstance(profile.get(\"id\"), (int, str)) and profile.get(\"id\"), \"Invalid or missing id\"\n        assert profile.get(\"username\") == username, \"Username mismatch\"\n        assert profile.get(\"email\") == email, \"Email mismatch\"\n        assert \"created_at\" in profile and profile[\"created_at\"], \"Missing created_at\"\n        assert \"last_login\" in profile, \"Missing last_login\"\n\n        # Profile retrieval with invalid token\n        invalid_token_header = {\"Authorization\": \"Bearer invalid.token.value\"}\n        invalid_resp = requests.get(f\"{BASE_URL}/me\", headers=invalid_token_header, timeout=TIMEOUT)\n        assert invalid_resp.status_code == 401, f\"Expected 401 Unauthorized for invalid token, got {invalid_resp.status_code}\"\n\n        # Profile retrieval with missing token\n        missing_token_resp = requests.get(f\"{BASE_URL}/me\", timeout=TIMEOUT)\n        assert missing_token_resp.status_code == 401, f\"Expected 401 Unauthorized for missing token, got {missing_token_resp.status_code}\"\n\n    finally:\n        # Cleanup: no direct delete user endpoint provided, so skipping deletion.\n        # If such an endpoint existed, we would delete the user here.\n        pass\n\n\ntest_authenticated_user_profile_retrieval()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-13T20:24:25.181Z",
    "modified": "2026-02-13T20:25:16.861Z"
  },
  {
    "projectId": "e033221d-4754-43c9-9221-ccf7efb399bf",
    "testId": "5d45dfd4-b4aa-4c39-8c0e-71f8c6a4be0f",
    "userId": "84b82428-8041-70a5-857a-0c34799496ce",
    "title": "TC005-image upload to s3 compatible storage with uuid path",
    "description": "Test the /images POST endpoint to upload image files as multipart/form-data. Verify images are stored in MinIO with UUID-based paths, database records are created, and only authenticated users can upload images.",
    "code": "import requests\nimport uuid\nimport io\n\nBASE_URL = \"http://localhost:8000\"\nREGISTER_URL = f\"{BASE_URL}/register\"\nLOGIN_URL = f\"{BASE_URL}/login\"\nIMAGES_URL = f\"{BASE_URL}/images\"\n\ndef test_image_upload_to_s3_with_uuid_path():\n    username = f\"testuser_{uuid.uuid4().hex[:8]}\"\n    password = \"TestPassword123!\"\n    email = f\"{username}@example.com\"\n    # Register user\n    register_payload = {\n        \"username\": username,\n        \"password\": password,\n        \"email\": email,\n    }\n    try:\n        r = requests.post(REGISTER_URL, json=register_payload, timeout=30)\n        assert r.status_code == 200, f\"Register failed: {r.text}\"\n        token = r.json().get(\"access_token\")\n        assert token, \"No access_token returned after register\"\n    except Exception as e:\n        raise AssertionError(f\"Exception during user registration: {e}\")\n\n    # Login user\n    login_payload = {\n        \"username\": username,\n        \"password\": password,\n        \"remember_me\": False,\n    }\n    try:\n        r = requests.post(LOGIN_URL, json=login_payload, timeout=30)\n        assert r.status_code == 200, f\"Login failed: {r.text}\"\n        login_token = r.json().get(\"access_token\")\n        assert login_token, \"No access_token returned after login\"\n    except Exception as e:\n        raise AssertionError(f\"Exception during user login: {e}\")\n\n    auth_header = {\"Authorization\": f\"Bearer {login_token}\"}\n\n    # Prepare a small PNG image in memory for upload\n    png_header = b\"\\x89PNG\\r\\n\\x1a\\n\"\n    fake_png_data = png_header + b\"\\x00\" * 1024  # 1KB fake PNG data\n    file_name = \"test_image.png\"\n    files = {\n        \"file\": (file_name, io.BytesIO(fake_png_data), \"image/png\")\n    }\n\n    image_id = None\n\n    try:\n        # Upload image with authentication\n        upload_resp = requests.post(IMAGES_URL, files=files, headers=auth_header, timeout=30)\n        assert upload_resp.status_code == 200, f\"Image upload failed: {upload_resp.text}\"\n        resp_json = upload_resp.json()\n        image_id_str = resp_json.get(\"id\")\n        url = resp_json.get(\"url\")\n        assert image_id_str is not None, \"Response missing image id\"\n        assert url is not None and url != \"\", \"Response missing url\"\n\n        # image_id is integer per spec\n        try:\n            image_id = int(image_id_str)\n        except Exception:\n            raise AssertionError(\"Returned image id is not an integer\")\n\n        # Verify url contains a UUID-based path (UUID format in URL path)\n        # Extract the path part and check for uuid pattern\n        # Since UUID is canonical 8-4-4-4-12 hex digits\n        import re\n        uuid_regex = re.compile(\n            r\"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}\"\n        )\n        assert uuid_regex.search(url), \"URL does not contain a valid UUID path\"\n\n        # Try uploading without auth header should return 401\n        upload_resp_unauth = requests.post(IMAGES_URL, files=files, timeout=30)\n        assert upload_resp_unauth.status_code == 401, \"Unauthenticated upload should fail with 401\"\n\n    finally:\n        # Cleanup: delete the uploaded image if created\n        if image_id is not None:\n            delete_url = f\"{IMAGES_URL}/{image_id}\"\n            try:\n                del_resp = requests.delete(delete_url, headers=auth_header, timeout=30)\n                assert del_resp.status_code == 200, f\"Image deletion failed: {del_resp.text}\"\n            except Exception as e:\n                # Log deletion error but don't fail test because cleanup failed\n                print(f\"Cleanup deletion failed: {e}\")\n\ntest_image_upload_to_s3_with_uuid_path()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-13T20:24:25.186Z",
    "modified": "2026-02-13T20:25:09.730Z"
  },
  {
    "projectId": "e033221d-4754-43c9-9221-ccf7efb399bf",
    "testId": "eb1b2fd9-2719-4bfe-b2f1-7d9038d7ebad",
    "userId": "84b82428-8041-70a5-857a-0c34799496ce",
    "title": "TC006-request asynchronous image transformation via kafka",
    "description": "Test the /images/{image_id}/transform endpoint to request image transformations. Verify that transformation tasks are enqueued to Kafka for background processing, only authenticated users can request transformations on their own images, and invalid image IDs return 404.",
    "code": "import requests\nimport uuid\nimport io\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_request_async_image_transformation_via_kafka():\n    session = requests.Session()\n\n    username = f\"user_{uuid.uuid4().hex[:8]}\"\n    password = \"TestPass123!\"\n    email = f\"{username}@example.com\"\n\n    # Register user\n    register_payload = {\n        \"username\": username,\n        \"password\": password,\n        \"email\": email\n    }\n    r = session.post(f\"{BASE_URL}/register\", json=register_payload, timeout=TIMEOUT)\n    assert r.status_code == 200, f\"Registration failed: {r.text}\"\n    access_token = r.json().get(\"access_token\")\n    assert access_token, \"No access token returned on registration\"\n\n    headers = {\"Authorization\": f\"Bearer {access_token}\"}\n\n    image_id = None\n\n    try:\n        # Upload image to create a resource\n        image_content = io.BytesIO(b\"fake image content for testing\")\n        files = {\"file\": (\"test_image.png\", image_content, \"image/png\")}\n        r = session.post(f\"{BASE_URL}/images\", headers=headers, files=files, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Image upload failed: {r.text}\"\n        image_resp = r.json()\n        assert \"id\" in image_resp, f\"No image id in response: {r.text}\"\n        try:\n            image_id = int(image_resp[\"id\"])\n        except Exception:\n            assert False, f\"Image id is not an integer: {image_resp['id']}\"\n\n        # Request image transformation with valid image_id and auth\n        transform_payload = {\n            \"transformations\": {\n                \"resize\": {\"width\": 100, \"height\": 100},\n                \"grayscale\": True\n            }\n        }\n        r = session.post(f\"{BASE_URL}/images/{image_id}/transform\", headers=headers, json=transform_payload, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Transform request failed: {r.text}\"\n        resp_json = r.json()\n        assert \"message\" in resp_json\n        assert \"procesar√° en background\" in resp_json[\"message\"]\n\n        # Request transformation with invalid image_id returns 404\n        invalid_image_id = 9999999\n        r = session.post(f\"{BASE_URL}/images/{invalid_image_id}/transform\", headers=headers, json=transform_payload, timeout=TIMEOUT)\n        assert r.status_code == 404, f\"Expected 404 for invalid image_id but got {r.status_code}\"\n\n        # Register a second user to test access control\n        username2 = f\"user_{uuid.uuid4().hex[:8]}\"\n        email2 = f\"{username2}@example.com\"\n        register_payload2 = {\n            \"username\": username2,\n            \"password\": password,\n            \"email\": email2\n        }\n        r = session.post(f\"{BASE_URL}/register\", json=register_payload2, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Second registration failed: {r.text}\"\n        access_token2 = r.json().get(\"access_token\")\n        assert access_token2, \"No access token returned for second user\"\n        headers2 = {\"Authorization\": f\"Bearer {access_token2}\"}\n\n        # Second user tries to request transformation on first user's image\n        r = session.post(f\"{BASE_URL}/images/{image_id}/transform\", headers=headers2, json=transform_payload, timeout=TIMEOUT)\n        assert r.status_code == 404, f\"Expected 404 when requesting transform for image not owned by user2, got {r.status_code}\"\n\n    finally:\n        # Cleanup: delete created image as original user\n        if image_id:\n            del_response = session.delete(f\"{BASE_URL}/images/{image_id}\", headers=headers, timeout=TIMEOUT)\n            assert del_response.status_code == 200, f\"Image deletion failed: {del_response.text}\"\n\ntest_request_async_image_transformation_via_kafka()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-13T20:24:25.191Z",
    "modified": "2026-02-13T20:25:23.841Z"
  },
  {
    "projectId": "e033221d-4754-43c9-9221-ccf7efb399bf",
    "testId": "69e2e183-bc4f-445f-bd18-112f9815aa13",
    "userId": "84b82428-8041-70a5-857a-0c34799496ce",
    "title": "TC007-get image details by id with access control",
    "description": "Test the /images/{image_id} GET endpoint to retrieve image information by ID. Ensure only the owner can access the image details and invalid or unauthorized access returns 404.",
    "code": "import requests\nimport tempfile\nimport os\nimport random\nimport string\nimport uuid\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n\ndef random_string(length=8):\n    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n\n\ndef register_user(username, password, email):\n    url = f\"{BASE_URL}/register\"\n    payload = {\n        \"username\": username,\n        \"password\": password,\n        \"email\": email\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    data = resp.json()\n    assert \"access_token\" in data\n    return data[\"access_token\"]\n\n\ndef upload_image(token, file_path):\n    url = f\"{BASE_URL}/images\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    with open(file_path, \"rb\") as f:\n        files = {\"file\": (os.path.basename(file_path), f, \"application/octet-stream\")}\n        resp = requests.post(url, headers=headers, files=files, timeout=TIMEOUT)\n    resp.raise_for_status()\n    data = resp.json()\n    assert \"id\" in data and \"url\" in data\n    return data[\"id\"]\n\n\ndef get_image(token, image_id):\n    url = f\"{BASE_URL}/images/{image_id}\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    return requests.get(url, headers=headers, timeout=TIMEOUT)\n\n\ndef delete_image(token, image_id):\n    url = f\"{BASE_URL}/images/{image_id}\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    resp = requests.delete(url, headers=headers, timeout=TIMEOUT)\n    # Could be 200 or 404 if already deleted\n    return resp\n\n\ndef test_TC007_get_image_details_by_id_with_access_control():\n    # Register first user (owner)\n    owner_username = f\"owner_{random_string()}\"\n    owner_password = \"StrongPass!123\"\n    owner_email = f\"{owner_username}@example.com\"\n    owner_token = register_user(owner_username, owner_password, owner_email)\n\n    # Register second user (non-owner)\n    other_username = f\"other_{random_string()}\"\n    other_password = \"StrongPass!123\"\n    other_email = f\"{other_username}@example.com\"\n    other_token = register_user(other_username, other_password, other_email)\n\n    # Create a temporary file to upload\n    tmp_file = tempfile.NamedTemporaryFile(delete=False)\n    try:\n        tmp_file.write(os.urandom(1024))  # 1KB random content\n        tmp_file.close()\n\n        image_id = None\n        try:\n            # Owner uploads an image\n            image_id = upload_image(owner_token, tmp_file.name)\n\n            # Owner accesses the image details - expect 200\n            resp_owner = get_image(owner_token, image_id)\n            assert resp_owner.status_code == 200\n            data_owner = resp_owner.json()\n            assert \"id\" in data_owner and data_owner[\"id\"] == image_id\n            assert \"url\" in data_owner and isinstance(data_owner[\"url\"], str) and data_owner[\"url\"]\n\n            # Non-owner accesses same image details - expect 404\n            resp_other = get_image(other_token, image_id)\n            assert resp_other.status_code == 404\n\n            # Access with invalid token - expect 401 (per PRD for auth required endpoint)\n            resp_invalid_auth = requests.get(f\"{BASE_URL}/images/{image_id}\",\n                                            headers={\"Authorization\": \"Bearer invalidtoken\"},\n                                            timeout=TIMEOUT)\n            assert resp_invalid_auth.status_code == 401\n\n            # Access without authentication - expect 401\n            resp_no_auth = requests.get(f\"{BASE_URL}/images/{image_id}\", timeout=TIMEOUT)\n            assert resp_no_auth.status_code == 401\n\n            # Request non-existent image by owner - expect 404\n            non_existent_id = str(uuid.uuid4())\n            resp_non_exist = get_image(owner_token, non_existent_id)\n            assert resp_non_exist.status_code == 404\n\n        finally:\n            # Cleanup: delete image by owner if created\n            if image_id is not None:\n                delete_resp = delete_image(owner_token, image_id)\n                # Expect 200 or 404 if already deleted\n                assert delete_resp.status_code in (200, 404)\n\n    finally:\n        os.unlink(tmp_file.name)\n\n\ntest_TC007_get_image_details_by_id_with_access_control()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nConnectionResetError: [Errno 104] Connection reset by peer\n\nThe above exception was the direct cause of the following exception:\n\nurllib3.exceptions.ProxyError: ('Unable to connect to proxy', ConnectionResetError(104, 'Connection reset by peer'))\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 519, in increment\n    raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nurllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Max retries exceeded with url: http://localhost:8000/register (Caused by ProxyError('Unable to connect to proxy', ConnectionResetError(104, 'Connection reset by peer')))\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 117, in <module>\n  File \"<string>\", line 61, in test_TC007_get_image_details_by_id_with_access_control\n  File \"<string>\", line 23, in register_user\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 694, in send\n    raise ProxyError(e, request=request)\nrequests.exceptions.ProxyError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Max retries exceeded with url: http://localhost:8000/register (Caused by ProxyError('Unable to connect to proxy', ConnectionResetError(104, 'Connection reset by peer')))\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-13T20:24:25.196Z",
    "modified": "2026-02-13T20:26:41.159Z"
  },
  {
    "projectId": "e033221d-4754-43c9-9221-ccf7efb399bf",
    "testId": "6f6bf1e4-a046-4bc0-9809-9256ed4f1fde",
    "userId": "84b82428-8041-70a5-857a-0c34799496ce",
    "title": "TC008-delete image by id with secure ownership verification",
    "description": "Test the /images/{image_id} DELETE endpoint to delete images. Verify that images are removed from both MinIO storage and database records, only owners can delete their images, and invalid image IDs return 404.",
    "code": "import requests\nimport uuid\nimport io\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n\ndef register_user(username, password, email):\n    payload = {\"username\": username, \"password\": password, \"email\": email}\n    r = requests.post(f\"{BASE_URL}/register\", json=payload, timeout=TIMEOUT)\n    r.raise_for_status()\n    data = r.json()\n    assert \"access_token\" in data\n    return data[\"access_token\"]\n\n\ndef upload_image(token, file_bytes, filename=\"test-image.png\"):\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    files = {\"file\": (filename, file_bytes, \"image/png\")}\n    r = requests.post(f\"{BASE_URL}/images\", headers=headers, files=files, timeout=TIMEOUT)\n    r.raise_for_status()\n    data = r.json()\n    assert \"id\" in data and \"url\" in data\n    return int(data[\"id\"])\n\n\ndef delete_image(token, image_id):\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    r = requests.delete(f\"{BASE_URL}/images/{image_id}\", headers=headers, timeout=TIMEOUT)\n    return r\n\n\ndef get_image(token, image_id):\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    r = requests.get(f\"{BASE_URL}/images/{image_id}\", headers=headers, timeout=TIMEOUT)\n    return r\n\n\ndef test_delete_image_by_id_with_secure_ownership_verification():\n    # Register two users\n    username1 = f\"user1_{uuid.uuid4().hex[:8]}\"\n    username2 = f\"user2_{uuid.uuid4().hex[:8]}\"\n    password = \"StrongPass!23\"\n    email1 = f\"{username1}@example.com\"\n    email2 = f\"{username2}@example.com\"\n\n    token1 = register_user(username1, password, email1)\n    token2 = register_user(username2, password, email2)\n\n    # Upload an image as user1\n    image_content = io.BytesIO(b\"PNGDATA\" * 100)  # fake image content\n    image_id = None\n\n    try:\n        image_id = upload_image(token1, image_content)\n\n        # User1 deletes their own image successfully\n        r_delete_owner = delete_image(token1, image_id)\n        assert r_delete_owner.status_code == 200\n        resp = r_delete_owner.json()\n        assert resp.get(\"message\") == \"Imagen eliminada exitosamente\"\n\n        # Confirm image is deleted (should return 404)\n        r_get_deleted = get_image(token1, image_id)\n        assert r_get_deleted.status_code == 404\n\n        # Upload another image as user1 for ownership test\n        image_id = upload_image(token1, io.BytesIO(b\"PNGDATA\" * 100))\n\n        # User2 tries to delete user1's image -> should be 404 (not found or unauthorized)\n        r_delete_not_owner = delete_image(token2, image_id)\n        assert r_delete_not_owner.status_code == 404\n\n        # Confirm image still exists for user1\n        r_get_owner = get_image(token1, image_id)\n        assert r_get_owner.status_code == 200\n\n        # Test deletion of invalid/non-existent image id returns 404\n        invalid_id = 99999999\n        r_delete_invalid = delete_image(token1, invalid_id)\n        assert r_delete_invalid.status_code == 404\n\n    finally:\n        # Cleanup: try deleting the image if still exists and owned by user1\n        if image_id is not None:\n            try:\n                delete_image(token1, image_id)\n            except Exception:\n                pass\n\n\ntest_delete_image_by_id_with_secure_ownership_verification()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-13T20:24:25.201Z",
    "modified": "2026-02-13T20:25:41.541Z"
  }
]
